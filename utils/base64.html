<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base64 인코더 & 디코더</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }
        h1, h2 {
            text-align: center;
            color: #1a73e8;
            margin-top: 0;
            padding: 20px;
            background-color: #e8f0fe;
        }
        h2 {
            background-color: transparent;
            border-bottom: 2px solid #e8f0fe;
            margin: 0 20px;
            padding: 20px 0 10px 0;
            text-align: left;
        }
        .section {
            padding: 20px;
        }
        .section + .section {
            border-top: 1px solid #eee;
        }
        textarea {
            width: 100%;
            height: 150px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            font-size: 14px;
            margin-top: 10px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            background-color: #1a73e8;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #1558b0;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .file-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        input[type="file"] {
            font-size: 14px;
        }
        .download-inputs {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .download-inputs .mime-input-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .download-inputs .mime-input-wrapper select,
        .download-inputs .mime-input-wrapper input {
            width: 100%;
            box-sizing: border-box;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        .download-inputs .mime-input-wrapper select {
            background-color: white;
            height: 38px;
        }
        .download-inputs input#file-filename {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            height: 38px;
            box-sizing: border-box;
        }
        .result-box {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
            min-height: 50px;
            word-wrap: break-word;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .error {
            color: #d93025;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
        }
        img#image-preview {
            display: none;
            max-width: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        /* [변경] 미리보기 안내 메시지 */
        #preview-message {
            display: block; /* 항상 표시되도록 block으로 변경 */
            text-align: center;
            font-style: italic;
            color: #555;
            margin-top: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Base64 인코더 & 디코더</h1>

        <div class="section">
            <h2>1. 텍스트 (Text)</h2>
            <textarea id="text-input" placeholder="여기에 텍스트를 입력하세요... (한글 포함 가능)"></textarea>
            <div class="controls">
                <button id="text-encode-btn">▼ 인코딩 (Encode) ▼</button>
                <button id="text-decode-btn">▲ 디코딩 (Decode) ▲</button>
            </div>
            <textarea id="text-output" placeholder="...결과가 여기에 표시됩니다."></textarea>
            <p id="text-error" class="error"></p>
        </div>

        <div class="section">
            <h2>2. 파일 → Base64 인코딩</h2>
            <div class="file-controls">
                <input type="file" id="file-input">
                <p>결과 (Base64 문자열):</p>
                <div id="file-encode-output" class="result-box">파일을 선택하세요.</div>
                <p id="file-encode-error" class="error"></p>
            </div>
        </div>

        <div class="section">
            <h2>3. Base64 → 파일 디코딩 (다운로드)</h2>
            <textarea id="file-decode-input" placeholder="여기에 Base64 문자열을 붙여넣으세요..."></textarea>
            
            <div class="download-inputs">
                <div class="mime-input-wrapper">
                    <select id="mime-type-select">
                        <option value="">-- MIME 타입 선택 --</option>
                        <option value="image/png">Image - PNG (.png)</option>
                        <option value="image/jpeg">Image - JPEG (.jpg)</option>
                        <option value="image/gif">Image - GIF (.gif)</option>
                        <option value="image/svg+xml">Image - SVG (.svg)</option>
                        <option value="image/webp">Image - WebP (.webp)</option>
                        <option value="application/pdf">Document - PDF (.pdf)</option>
                        <option value="text/plain">Text - Plain (.txt)</option>
                        <option value="text/html">Text - HTML (.html)</option>
                        <option value="application/json">Data - JSON (.json)</option>
                        <option value="application/xml">Data - XML (.xml)</option>
                        <option value="application/octet-stream">Binary - Default</option>
                        <option value="other">[사용자 직접 입력]</option>
                    </select>
                    <input type="text" id="mime-type-custom" placeholder="MIME 타입 직접 입력 (예: image/png)" style="display: none;">
                </div>
                <input type="text" id="file-filename" placeholder="저장할 파일명 (예: download.png)">
            </div>

            <div class="controls">
                <button id="file-decode-btn">파일로 디코딩 및 다운로드</button>
            </div>
            <p id="file-decode-error" class="error"></p>
            
            <p id="preview-message">
                MIME 타입이 'image/...'인 경우, Base64 데이터를 입력하면 여기에 미리보기가 표시됩니다.
            </p>
            
            <img id="image-preview" alt="이미지 미리보기 영역">
        </div>

    </div>

    <script>
        // --- 유틸리티 함수 ---
        function textToBase64(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            const binaryString = Array.from(data, (byte) => String.fromCharCode(byte)).join('');
            return btoa(binaryString);
        }

        function base64ToText(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const decoder = new TextDecoder();
            return decoder.decode(bytes);
        }

        function base64ToBlob(base64, mimeType) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return new Blob([bytes], { type: mimeType });
        }


        // --- 1. 텍스트 변환 이벤트 핸들러 ---
        const textInput = document.getElementById('text-input');
        const textOutput = document.getElementById('text-output');
        const textError = document.getElementById('text-error');

        document.getElementById('text-encode-btn').addEventListener('click', () => {
            try {
                textError.textContent = '';
                textOutput.value = textToBase64(textInput.value);
            } catch (e) {
                console.error(e);
                textError.textContent = '인코딩 중 오류가 발생했습니다.';
            }
        });

        document.getElementById('text-decode-btn').addEventListener('click', () => {
            try {
                textError.textContent = '';
                textInput.value = base64ToText(textOutput.value);
            } catch (e) {
                console.error(e);
                textError.textContent = '디코딩 중 오류가 발생했습니다. 유효한 Base64 문자열인지 확인하세요.';
            }
        });


        // --- 2. 파일 인코딩 이벤트 핸들러 ---
        const fileInput = document.getElementById('file-input');
        const fileEncodeOutput = document.getElementById('file-encode-output');
        const fileEncodeError = document.getElementById('file-encode-error');

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            fileEncodeError.textContent = '';
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                const base64 = dataUrl.split(',')[1];
                fileEncodeOutput.textContent = base64;
            };
            reader.onerror = (e) => {
                console.error(e);
                fileEncodeError.textContent = '파일을 읽는 중 오류가 발생했습니다.';
            };
            reader.readAsDataURL(file);
        });


        // --- 3. 파일 디코딩 이벤트 핸들러 ---
        const fileDecodeInput = document.getElementById('file-decode-input');
        const fileFilename = document.getElementById('file-filename');
        const fileDecodeError = document.getElementById('file-decode-error');
        const imgPreview = document.getElementById('image-preview');
        
        const mimeSelect = document.getElementById('mime-type-select');
        const customMimeInput = document.getElementById('mime-type-custom');
        const previewMessage = document.getElementById('preview-message'); // 이 변수는 있지만, display 제어는 안 함

        function getSelectedMimeType() {
            const selected = mimeSelect.value;
            if (selected === 'other') {
                return customMimeInput.value;
            }
            return selected;
        }

        document.getElementById('file-decode-btn').addEventListener('click', () => {
            fileDecodeError.textContent = '';
            
            const base64 = fileDecodeInput.value;
            const mimeType = getSelectedMimeType() || 'application/octet-stream';
            const filename = fileFilename.value || 'downloaded-file';

            if (!base64) {
                fileDecodeError.textContent = 'Base64 문자열을 입력하세요.';
                return;
            }
            if (!mimeType) {
                fileDecodeError.textContent = 'MIME 타입을 선택하거나 입력하세요.';
                return;
            }

            try {
                const blob = base64ToBlob(base64, mimeType);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error(e);
                fileDecodeError.textContent = '디코딩 또는 다운로드 중 오류가 발생했습니다. Base64 문자열을 확인하세요.';
            }
        });

        // [변경] Base64 입력 또는 MIME 타입 변경 시 미리보기 업데이트
        function updatePreview() {
            const base64 = fileDecodeInput.value;
            const mimeType = getSelectedMimeType();

            // previewMessage.style.display 제어 코드 제거 (항상 표시됨)

            if (mimeType.startsWith('image/')) {
                if (base64) {
                    // Base64 데이터가 있으면 이미지 표시
                    const dataUrl = `data:${mimeType};base64,${base64}`;
                    imgPreview.src = dataUrl;
                    imgPreview.style.display = 'block';
                } else {
                    // Base64 데이터가 없으면 이미지 숨김
                    imgPreview.style.display = 'none';
                }
            } else {
                // 이미지 타입이 아니면 이미지 숨김
                imgPreview.style.display = 'none';
            }
        }

        mimeSelect.addEventListener('change', () => {
            if (mimeSelect.value === 'other') {
                customMimeInput.style.display = 'block';
                customMimeInput.focus();
            } else {
                customMimeInput.style.display = 'none';
            }
            updatePreview();
        });

        fileDecodeInput.addEventListener('input', updatePreview);
        customMimeInput.addEventListener('input', updatePreview);

        imgPreview.onerror = () => {
            imgPreview.style.display = 'none';
            fileDecodeError.textContent = '이미지 미리보기에 실패했습니다. Base64 문자열 또는 MIME 타입을 확인하세요.';
        };
        imgPreview.onload = () => {
            fileDecodeError.textContent = '';
        };

    </script>

</body>
</html>